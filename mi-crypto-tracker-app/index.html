<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Tracker Online (Backend Driven)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            margin-bottom: 20px;
        }
        .top-section-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 95%;
            max-width: 1200px;
            margin-bottom: 20px;
        }
        #controls {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            flex: 1;
            min-width: 280px;
        }
        #coin-select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: #e0e0e0;
            font-size: 1em;
            width: 100%;
        }
        #update-timer {
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
        }
        #signals-panel {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
            width: 95%;
            max-width: 1200px;
        }
        .signal {
            padding: 15px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            flex-grow: 1;
            min-width: 150px;
        }
        .buy { background-color: #28a745; color: white; }
        .sell { background-color: #dc3545; color: white; }
        .hold { background-color: #6c757d; color: white; }
        .overbought { background-color: #ffc107; color: #121212; }
        .oversold { background-color: #17a2b8; color: white; }
        .alert-buy {
            animation: pulse-buy 1s infinite alternate;
            border: 2px solid #28a745;
        }
        .alert-sell {
            animation: pulse-sell 1s infinite alternate;
            border: 2px solid #dc3545;
        }
        @keyframes pulse-buy {
            from { box-shadow: 0 0 5px #28a745; }
            to { box-shadow: 0 0 20px #28a745; }
        }
        @keyframes pulse-sell {
            from { box-shadow: 0 0 5px #dc3545; }
            to { box-shadow: 0 0 20px #dc3545; }
        }
        .chart-container {
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            margin-top: 20px;
            height: 450px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .no-data-message {
            color: #e0e0e0;
            font-size: 1.5em;
            text-align: center;
        }
        
        #current-opportunities-board {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            flex: 3;
            min-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #current-opportunities-board h2 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 5px;
            text-align: center;
        }
        .opportunity-columns {
            display: flex;
            gap: 10px;
            flex-grow: 1;
            min-height: 200px;
        }
        .opportunity-column {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 6px;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .opportunity-column h3 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            text-align: center;
        }
        .opportunity-column ul {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            overflow-y: auto;
            flex-grow: 1;
        }
        .opportunity-column li {
            background-color: #333;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 1em;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }
        .opportunity-column li:last-child {
            margin-bottom: 0;
        }
        .col-buy li { border-left: 4px solid #28a745; }
        .col-sell li { border-left: 4px solid #dc3545; }
        .col-hold li { border-left: 4px solid #6c757d; }

        #indicator-selection-panel {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            margin-top: 20px;
            width: 95%;
            max-width: 1200px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            align-items: center;
        }
        #indicator-selection-panel div {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #indicator-selection-panel label {
            font-size: 1em;
            color: #e0e0e0;
            cursor: pointer;
        }
        #indicator-selection-panel input[type="checkbox"] {
            transform: scale(1.2);
            cursor: pointer;
        }
        /* NUEVOS ESTILOS PARA LAS 3 COLUMNAS DEL HISTORIAL */
        #backend-historical-board {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            margin-top: 20px;
            width: 95%;
            max-width: 1200px;
            display: flex;
            flex-direction: column; /* Columna para el título, luego las sub-columnas */
            gap: 10px;
        }
        #backend-historical-board h2 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 5px;
            text-align: center;
        }
        .history-columns-container { /* Nuevo contenedor para las 3 sub-columnas */
            display: flex;
            gap: 10px;
            flex-grow: 1;
            min-height: 250px; /* Altura mínima para que sean visibles */
        }
        .history-column {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 6px;
            flex: 1; /* Hace que cada columna ocupe el mismo espacio */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* Oculta contenido que se desborda para el scrollbar */
        }
        .history-column h3 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            text-align: center;
        }
        .history-column ul {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            overflow-y: auto; /* Permite scroll individual en cada columna */
            flex-grow: 1;
        }
        .history-column li {
            background-color: #333;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 0.9em; /* Fuente un poco más pequeña para más entradas */
            display: flex;
            flex-direction: column; /* Apila symbol y timestamp */
            align-items: flex-start; /* Alinea texto a la izquierda en la lista */
            font-weight: bold;
            word-wrap: break-word; /* Para asegurar que el texto largo se ajuste */
        }
        .history-column li:last-child {
            margin-bottom: 0;
        }
        .historical-timestamp {
            font-size: 0.7em; /* Fuente más pequeña para el timestamp */
            color: #aaa;
            font-weight: normal;
        }
        .metric-info { /* Contenedor para acierto/riesgo y valor */
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-weight: normal; /* Para que el texto sea normal por defecto */
        }
        /* Estilos para las métricas de acierto/riesgo en el historial */
        .metric-acierto { color: #28a745; font-weight: bold; } /* Verde para acierto */
        .metric-riesgo { color: #dc3545; font-weight: bold; } /* Rojo para riesgo */
        .metric-na { color: #6c757d; } /* Gris para N/A */
        .metric-value { margin-left: 5px; font-size: 0.9em; font-weight: bold;} /* Porcentaje */

        /* Paginación */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: #1e1e1e;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .pagination-controls button {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        .pagination-controls button:hover:not(:disabled) {
            background-color: #555;
        }
        .pagination-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .pagination-controls span {
            font-size: 1em;
            color: #e0e0e0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2"></script>
</head>
<body>
    <script>
// Agrega esta funcion nueva junto con las demas
async function loadCurrentOpportunitiesFromBackend() {
    try {
        const response = await fetch(`${BACKEND_URL}/get_current_opportunities`);
        if (!response.ok) {
            console.error("Error al obtener oportunidades actuales:", response.statusText);
            return;
        }
        const data = await response.json();
        renderOpportunityColumns(data);
    } catch (error) {
        console.error("Fallo en la carga de oportunidades desde backend:", error);
    }
}

// Llama esta funcion cada 5 minutos
setInterval(loadCurrentOpportunitiesFromBackend, UPDATE_INTERVAL_ALL_CRYPTOS);

// Llamar al iniciar
loadCurrentOpportunitiesFromBackend();
</script>
    <h1>Crypto Tracker Online (Backend Driven)</h1>

    <div class="top-section-container">
        <div id="controls">
            <label for="coin-select">Elige una Criptomoneda:</label>
            <select id="coin-select">
                <!-- Las opciones se llenarán dinámicamente por JavaScript -->
                <option value="">Cargando criptomonedas...</option> 
            </select>
            <div id="update-timer"></div>
            <p style="font-size: 0.8em; color: #888; margin-top: 10px;">
                La lista de criptomonedas se carga dinámicamente desde KuCoin.
            </p>
        </div>

        <div id="current-opportunities-board">
            <h2>Oportunidades de Trading (Todas las Criptos)</h2>
            <div class="opportunity-columns">
                <div class="opportunity-column col-buy">
                    <h3>COMPRA</h3>
                    <ul id="buy-list">
                        <li>Cargando...</li> 
                    </ul>
                </div>
                <div class="opportunity-column col-sell">
                    <h3>VENTA</h3>
                    <ul id="sell-list">
                        <li>Cargando...</li>
                    </ul>
                </div>
                <div class="opportunity-column col-hold">
                    <h3>MANTENER</h3>
                    <ul id="hold-list">
                        <li>Cargando...</li>
                    </ul>
                </div>
            </div>
            <p style="font-size: 0.8em; color: #888; margin-top: 10px; text-align: center;">
                Recomendaciones basadas en análisis técnico (SMA, RSI, BB) para todas las criptomonedas listadas.
                La actualización de esta sección se realiza progresivamente.
            </p>
        </div>
    </div>

    <!-- Panel de Selección de Indicadores -->
    <div id="indicator-selection-panel" class="container">
        <div>
            <input type="checkbox" id="toggle-sma-short" checked>
            <label for="toggle-sma-short">SMA Corta</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-sma-long" checked>
            <label for="toggle-sma-long">SMA Larga</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-bb-upper" checked>
            <label for="toggle-bb-upper">BB Superior</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-bb-middle" checked>
            <label for="toggle-bb-middle">BB Media</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-bb-lower" checked>
            <label for="toggle-bb-lower">BB Inferior</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-rsi" checked>
            <label for="toggle-rsi">RSI</label>
        </div>
    </div>

    <div id="signals-panel" class="container">
        <div id="sma-signal" class="signal hold">Cargando...</div>
        <div id="rsi-signal" class="signal hold">Cargando...</div>
        <div id="bb-signal" class="signal hold">Cargando...</div>
    </div>
    
    <div id="price-chart-container" class="chart-container container">
        <canvas id="priceChart"></canvas>
        <div id="price-no-data" class="no-data-message" style="display:none;">No hay datos para mostrar el gráfico de precios.</div>
    </div>
    
    <!-- Nuevo Tablero de Historial del Backend -->
    <div id="backend-historical-board" class="container">
        <h2>Historial de Recomendaciones (Desde Backend)</h2>
        <div class="history-columns-container"> <!-- Contenedor para las 3 sub-columnas -->
            <div class="history-column">
                <h3>Todas las Criptos</h3>
                <ul id="all-history-list">
                    <li>Cargando...</li>
                </ul>
            </div>
            <div class="history-column">
                <h3>Aciertos</h3>
                <ul id="aciertos-list">
                    <li>Cargando...</li>
                </ul>
            </div>
            <div class="history-column">
                <h3>Riesgos</h3>
                <ul id="riesgos-list">
                    <li>Cargando...</li>
                </ul>
            </div>
        </div>
        <!-- Controles de Paginación -->
        <div class="pagination-controls">
            <button id="prev-page-btn" disabled>Anterior</button>
            <span id="page-info">Página 1 de 1</span>
            <button id="next-page-btn" disabled>Siguiente</button>
        </div>
        <p style="font-size: 0.8em; color: #888; margin-top: 10px; text-align: center;">
            Este historial se guarda y recupera desde el servidor backend (archivo data.csv).
        </p>
    </div>

    <script>
        // ===================================================================================
        // --- CONFIGURACIÓN E INICIALIZACIÓN ---
        // ===================================================================================

        // URL BASE DE TU BACKEND 
        const BACKEND_URL = 'https://crypto-tracker-ukyl.onrender.com'; 

        // Parámetros de la API de KuCoin (manejados por el backend)
        const KUCOIN_INTERVAL = "1hour"; 
        const KUCOIN_LIMIT = 200; 

        // Intervalos de actualización para el frontend
        const UPDATE_INTERVAL_SELECTED_CRYPTO = 120000; // 2 minutos para actualizar el gráfico de la crypto seleccionada
        const UPDATE_INTERVAL_ALL_CRYPTOS = 5 * 60 * 1000; // 5 minutos para actualizar TODAS las oportunidades
        const HISTORY_UPDATE_INTERVAL = 60000; // 1 minuto para actualizar el historial

        const SMA_SHORT_PERIOD = 20;
        const SMA_LONG_PERIOD = 50;
        const BB_PERIOD = 20;
        const BB_STD_DEV = 2;
        const RSI_PERIOD = 14;
        const RSI_OVERBOUGHT = 70;
        const RSI_OVERSOLD = 30;

        const coinSelect = document.getElementById('coin-select');
        const updateTimerDiv = document.getElementById('update-timer');
        const smaSignalDiv = document.getElementById('sma-signal');
        const rsiSignalDiv = document.getElementById('rsi-signal');
        const bbSignalDiv = document.getElementById('bb-signal');
        
        const buyList = document.getElementById('buy-list');
        const sellList = document.getElementById('sell-list');
        const holdList = document.getElementById('hold-list');

        const priceChartCanvas = document.getElementById('priceChart');
        const priceNoDataMessage = document.getElementById('price-no-data');

        const toggleSmaShort = document.getElementById('toggle-sma-short');
        const toggleSmaLong = document.getElementById('toggle-sma-long');
        const toggleBbUpper = document.getElementById('toggle-bb-upper');
        const toggleBbMiddle = document.getElementById('toggle-bb-middle');
        const toggleBbLower = document.getElementById('toggle-bb-lower');
        const toggleRsi = document.getElementById('toggle-rsi');

        const allHistoryList = document.getElementById('all-history-list');
        const aciertosList = document.getElementById('aciertos-list');
        const riesgosList = document.getElementById('riesgos-list');

        // Paginación del historial
        const ROWS_PER_PAGE = 20; // Máximo de filas por página
        let currentPage = 1;
        let totalPages = 1;
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const pageInfoSpan = document.getElementById('page-info');


        let priceChartInstance, countdownInterval;
        let allCryptos = []; 

        let currentPriceDataCache = null;
        let currentSmaShortCache = null;
        let currentSmaLongCache = null;
        let currentBollingerBandsCache = null;
        let currentRsiCache = null; 

        // ===================================================================================
        // --- INICIALIZACIÓN DE LA APLICACIÓN ---
        // ===================================================================================

        // CAMBIADO: initStaticCryptoList -> initDynamicCryptoList (ahora hace la llamada al backend)
        async function initDynamicCryptoList() {
            console.log("initDynamicCryptoList: Cargando lista de criptomonedas dinámicamente desde el backend.");
            coinSelect.innerHTML = '<option value="">Cargando monedas...</option>'; // Mostrar estado de carga
            
            try {
                const response = await fetch(`${BACKEND_URL}/get_available_symbols`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Error HTTP al obtener símbolos del backend: ${response.status} - ${response.statusText}. Detalles: ${errorText}`);
                }
                const symbols = await response.json(); // Se espera una lista de strings (ej. ["BTC-USDT", "ETH-USDT"])

                coinSelect.innerHTML = ''; // Limpiar opciones de carga
                allCryptos = []; // Limpiar la lista global
                
                if (symbols.length === 0) {
                    coinSelect.innerHTML = '<option value="">No hay monedas disponibles.</option>';
                    console.warn("initDynamicCryptoList: No se recibieron símbolos del backend.");
                    return;
                }

                symbols.forEach(symbol => {
                    const option = document.createElement('option');
                    option.value = symbol;
                    // El backend ya envía el formato correcto (ej. BTC-USDT)
                    option.textContent = symbol; 
                    coinSelect.appendChild(option);
                    allCryptos.push(symbol);
                });

                // Seleccionar la primera criptomoneda por defecto
                if (allCryptos.length > 0) {
                    coinSelect.value = allCryptos[0];
                }
                console.log(`initDynamicCryptoList: Lista de ${allCryptos.length} criptomonedas cargada dinámicamente.`);

            } catch (error) {
                console.error("initDynamicCryptoList: Error al cargar la lista de criptomonedas:", error);
                coinSelect.innerHTML = '<option value="">Error al cargar monedas.</option>';
            }
        }


        // ===================================================================================
        // --- FUNCIONES DE OBTENCIÓN DE DATOS DESDE EL BACKEND (AHORA ES LA FUENTE) ---
        // ===================================================================================

        /**
         * Obtiene los últimos datos de análisis (klines y señales) para una criptomoneda específica desde el backend.
         * @param {string} symbol - El símbolo de la criptomoneda.
         * @returns {object} Un objeto con klines, indicadores y señales, o null si hay error.
         */
        async function getLatestAnalysisFromBackend(symbol) {
            console.log(`Frontend: Solicitando análisis más reciente de ${symbol} al backend.`);
            try {
                const response = await fetch(`${BACKEND_URL}/get_latest_analysis/${symbol}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Error HTTP al obtener análisis del backend: ${response.status} - ${response.statusText}. Detalles: ${errorText}`);
                }
                const data = await response.json();
                console.log(`Frontend: Análisis de ${symbol} recibido del backend.`, data);
                return data;
            }
            catch (error) {
                console.error(`Frontend: Error al obtener análisis de ${symbol} del backend:`, error);
                return null;
            }
        }

        // ===================================================================================
        // --- FUNCIONES DE CÁLCULO DE INDICADORES (AHORA SOLO PARA RENDERIZADO EN FRONT) ---
        // ===================================================================================
        // Estas funciones se mantienen como placeholders o para mapear datos si es necesario,
        // pero la lógica principal de cálculo está en el backend.
        function calculateSMA(data, period) { return data; } 
        function calculateBollingerBands(data, period, stdDevMultiplier) { return data; } 
        function calculateRSI(data, period) { return data; } 
        function getCombinedSignals(smaShort, smaLong, rsi, bollingerBands, closingPrices) { return { sma: 'N/A', rsi: 'N/A', bb: 'N/A', overall: 'hold' }; }


        // ===================================================================================
        // --- FUNCIONES DE RENDERING Y ACTUALIZACIÓN DE PANELES ---
        // ===================================================================================

        /**
         * Dibuja o actualiza el gráfico principal de precios, y los indicadores seleccionados.
         * Ahora los datos de los indicadores vienen directamente del backend.
         * Se asegura de que los datos de los indicadores sean arrays válidos antes de mapear.
         */
        function renderPriceChart(priceData, smaShort, smaLong, bb, rsi) {
            console.log("renderPriceChart: Iniciando renderizado del gráfico."); 
            if (priceChartInstance) priceChartInstance.destroy();

            const ctx = priceChartCanvas.getContext('2d');
            const datasets = [
                { 
                    label: 'Precio (USD)', 
                    data: priceData, 
                    borderColor: '#36a2eb', 
                    borderWidth: 2.5, 
                    pointRadius: 0, 
                    tension: 0.1, 
                    fill: false,
                    yAxisID: 'y-price' 
                }
            ];

            if (toggleSmaShort.checked && smaShort && Array.isArray(smaShort) && smaShort.length > 0) { 
                datasets.push({ label: `SMA ${SMA_SHORT_PERIOD}`, data: smaShort.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), borderColor: '#ffce56', borderWidth: 1.5, pointRadius: 0, fill: false, yAxisID: 'y-price' });
            }
            if (toggleSmaLong.checked && smaLong && Array.isArray(smaLong) && smaLong.length > 0) {
                datasets.push({ label: `SMA ${SMA_LONG_PERIOD}`, data: smaLong.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), borderColor: '#ff6384', borderWidth: 1.5, pointRadius: 0, fill: false, yAxisID: 'y-price' });
            }
            
            if (toggleBbUpper.checked && bb && bb.upper && Array.isArray(bb.upper) && bb.upper.length > 0) {
                datasets.push({ label: `BB Superior`, data: bb.upper.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), borderColor: 'rgba(153, 102, 255, 0.5)', borderWidth: 1, pointRadius: 0, fill: false, yAxisID: 'y-price' });
            }
            if (toggleBbLower.checked && bb && bb.lower && Array.isArray(bb.lower) && bb.lower.length > 0) {
                datasets.push({ label: `BB Inferior`, data: bb.lower.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), borderColor: 'rgba(153, 102, 255, 0.5)', borderWidth: 1, pointRadius: 0, fill: '-1', backgroundColor: 'rgba(153, 102, 255, 0.1)', hidden: false, yAxisID: 'y-price' });
            }
            if (toggleBbMiddle.checked && bb && bb.middle && Array.isArray(bb.middle) && bb.middle.length > 0) {
                datasets.push({ label: `BB Media`, data: bb.middle.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), borderColor: 'rgba(153, 102, 255, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], fill: false, yAxisID: 'y-price' });
            }

            if (toggleRsi.checked && rsi && Array.isArray(rsi) && rsi.length > 0) {
                datasets.push({ label: `RSI (${RSI_PERIOD})`, data: rsi.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), borderColor: '#4bc0c0', borderWidth: 1.5, pointRadius: 0, fill: false, yAxisID: 'y-rsi' });
            }

            const annotations = {};
            if (toggleRsi.checked) {
                annotations.rsiOverboughtLine = { type: 'line', yMin: RSI_OVERBOUGHT, yMax: RSI_OVERBOUGHT, borderColor: 'red', borderWidth: 1, borderDash: [5, 5], yAxisID: 'y-rsi', label: { content: 'Sobrecompra', enabled: true, position: 'start', color: '#e0e0e0', backgroundColor: 'rgba(255, 0, 0, 0.5)'} };
                annotations.rsiOversoldLine = { type: 'line', yMin: RSI_OVERSOLD, yMax: RSI_OVERSOLD, borderColor: 'green', borderWidth: 1, borderDash: [5, 5], yAxisID: 'y-rsi', label: { content: 'Sobreventa', enabled: true, position: 'start', color: '#e0e0e0', backgroundColor: 'rgba(0, 128, 0, 0.5)'} };
            }

            priceChartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { type: 'time', time: { unit: 'hour', tooltipFormat: 'HH:mm dd/MM/yy', displayFormats: { hour: 'HH:mm', day: 'dd/MM' } },
                            title: { display: true, text: 'Fecha/Hora', color: '#e0e0e0' }, ticks: { color: '#e0e0e0' }, grid: { color: '#333' } },
                        'y-price': { type: 'linear', display: true, position: 'left',
                            title: { display: true, text: 'Precio (USD)', color: '#e0e0e0' }, ticks: { color: '#e0e0e0' }, grid: { color: '#333' } },
                        'y-rsi': { type: 'linear', display: toggleRsi.checked, position: 'right', min: 0, max: 100,
                            title: { display: true, text: 'RSI', color: '#4bc0c0' }, ticks: { color: '#4bc0c0' }, grid: { drawOnChartArea: false } }
                    },
                    plugins: { tooltip: { mode: 'index', intersect: false }, legend: { labels: { color: '#e0e0e0' } }, annotation: { annotations: annotations } }
                }
            });
            console.log("Gráfico de precios con indicadores renderizado.");
        }
        
        // updateSignals ahora solo actualiza los paneles UI con la info recibida del backend
        function updateSignals(analysisData, closingPrices) { // Recibe analysisData del backend
            smaSignalDiv.classList.remove('alert-buy', 'alert-sell');
            rsiSignalDiv.classList.remove('alert-buy', 'alert-sell');
            bbSignalDiv.classList.remove('alert-buy', 'alert-sell');

            // Usar directamente las señales recibidas del backend
            const signals = {
                sma: analysisData.sma,
                rsi: analysisData.rsi,
                bb: analysisData.bb,
                overall: analysisData.overall_rec // overall_rec es la recomendación combinada
            };

            // SMA
            if (signals.sma === 'buy') { smaSignalDiv.textContent = 'Cruce SMA: COMPRA 📈'; smaSignalDiv.className = 'signal buy alert-buy'; }
            else if (signals.sma === 'sell') { smaSignalDiv.textContent = 'Cruce SMA: VENTA 📉'; smaSignalDiv.className = 'signal sell alert-sell'; }
            else if (signals.sma === 'hold') { smaSignalDiv.textContent = 'Cruce SMA: Mantener 😐'; smaSignalDiv.className = 'signal hold'; }
            else { smaSignalDiv.textContent = 'Cruce SMA: Datos insuficientes'; smaSignalDiv.className = 'signal hold'; } // N/A

            // RSI
            if (signals.rsi === 'buy') { rsiSignalDiv.textContent = `RSI: Sobreventa ✅`; rsiSignalDiv.className = 'signal oversold alert-buy'; }
            else if (signals.rsi === 'sell') { rsiSignalDiv.textContent = `RSI: Sobrecompra ⚠️`; rsiSignalDiv.className = 'signal overbought alert-sell'; }
            else if (signals.rsi === 'hold') { rsiSignalDiv.textContent = `RSI: Neutral ⚖️`; rsiSignalDiv.className = 'signal hold'; }
            else { rsiSignalDiv.textContent = 'RSI: Datos insuficientes'; rsiSignalDiv.className = 'signal hold'; } // N/A

            // BB
            if (signals.bb === 'buy') { bbSignalDiv.textContent = `BB: Precio bajo banda inferior ⬇️ (Compra)`; bbSignalDiv.className = 'signal buy alert-buy'; }
            else if (signals.bb === 'sell') { bbSignalDiv.textContent = `BB: Precio sobre banda superior ⬆️ (Venta)`; bbSignalDiv.className = 'signal sell alert-sell'; }
            else if (signals.bb === 'hold') { bbSignalDiv.textContent = `BB: Precio dentro de la banda 🔄`; bbSignalDiv.className = 'signal hold'; }
            else { bbSignalDiv.textContent = 'BB: Datos insuficientes'; bbSignalDiv.className = 'signal hold'; } // N/A
            
            console.log("Señales individuales actualizadas con datos del backend.");
        }
        
        /**
         * Función central para renderizar las 3 columnas de oportunidades en el DOM.
         * Se llama repetidamente durante la carga progresiva.
         * @param {object} recommendationsMap - Un objeto con arrays de símbolos para 'buy', 'sell', 'hold', 'error'.
         */
        function renderOpportunityColumns(recommendationsMap) {
            buyList.innerHTML = '';
            sellList.innerHTML = '';
            holdList.innerHTML = '';

            const hasData = recommendationsMap.buy.length > 0 || recommendationsMap.sell.length > 0 || recommendationsMap.hold.length > 0 || recommendationsMap.error.length > 0;
            
            if (!hasData && allCryptos.length > 0) { // Si no hay datos pero sí hay cryptos en la lista
                 buyList.innerHTML = '<li>Cargando...</li>';
                 sellList.innerHTML = '<li>Cargando...</li>';
                 holdList.innerHTML = '<li>Cargando...</li>';
            } else if (allCryptos.length === 0) { // Si no hay cryptos en la lista (error de carga inicial)
                buyList.innerHTML = '<li>No hay criptos para mostrar.</li>';
                sellList.innerHTML = '<li>No hay criptos para mostrar.</li>';
                holdList.innerHTML = '<li>No hay criptos para mostrar.</li>';
                return;
            }


            recommendationsMap.buy.sort().forEach(symbol => {
                const li = document.createElement('li');
                li.textContent = symbol;
                buyList.appendChild(li);
            });
            if (recommendationsMap.buy.length === 0 && hasData) buyList.innerHTML = '<li>Ninguna</li>';


            recommendationsMap.sell.sort().forEach(symbol => {
                const li = document.createElement('li');
                li.textContent = symbol;
                sellList.appendChild(li);
            });
            if (recommendationsMap.sell.length === 0 && hasData) sellList.innerHTML = '<li>Ninguna</li>';


            const allHoldSymbols = [...recommendationsMap.hold, ...recommendationsMap.error];
            allHoldSymbols.sort().forEach(symbol => {
                const li = document.createElement('li');
                li.textContent = symbol;
                holdList.appendChild(li);
            });
            if (allHoldSymbols.length === 0 && hasData) holdList.innerHTML = '<li>Ninguna</li>';

            if (!hasData && allCryptos.length > 0) { // Si no hay datos y ya terminó el procesamiento
                buyList.innerHTML = '<li>No hay oportunidades activas.</li>';
                sellList.innerHTML = '<li>No hay oportunidades activas.</li>';
                holdList.innerHTML = '<li>No hay oportunidades activas.</li>';
            }
        }

        function startUpdateTimer(seconds) {
            let remaining = seconds;
            updateTimerDiv.textContent = `Próxima actualización de gráficos en ${remaining}s...`;
            countdownInterval = setInterval(() => {
                remaining--;
                if (remaining >= 0) {
                    updateTimerDiv.textContent = `Próxima actualización de gráficos en ${remaining}s...`;
                }
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        // ===================================================================================
        // --- FUNCIONES DE PERSISTENCIA (INTERACCIÓN CON BACKEND) ---
        // ===================================================================================

        // saveRecommendationToBackend ahora es un placeholder, el scheduler del backend es el que guarda
        async function saveRecommendationToBackend(symbol, recommendation, individualSignals, currentPrice) { 
            console.warn(`saveRecommendationToBackend: Esta función es un placeholder. El backend ahora maneja el guardado programado.`);
            // No hacemos nada aquí ya que el backend lo hace automáticamente
        }

        async function loadHistoricalRecommendationsFromBackend() {
            allHistoryList.innerHTML = '<li>Cargando historial...</li>';
            aciertosList.innerHTML = '<li>Cargando...</li>';
            riesgosList.innerHTML = '<li>Cargando...</li>';

            console.log("Cargando historial desde backend:", `${BACKEND_URL}/get_recommendations?page=${currentPage}&limit=${ROWS_PER_PAGE}`); 
            try {
                const response = await fetch(`${BACKEND_URL}/get_recommendations?page=${currentPage}&limit=${ROWS_PER_PAGE}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Error HTTP al cargar historial desde backend: ${response.status} - ${response.statusText}. Detalles: ${errorText}`);
                }
                const data = await response.json(); 
                const history = data.recommendations;
                totalPages = data.total_pages;
                currentPage = data.current_page; // Asegurarse de que currentPage se actualice desde el backend
                pageInfoSpan.textContent = `Página ${data.current_page} de ${totalPages}`;
                prevPageBtn.disabled = (data.current_page === 1);
                nextPageBtn.disabled = (data.current_page === totalPages);


                allHistoryList.innerHTML = '';
                aciertosList.innerHTML = '';
                riesgosList.innerHTML = '';

                if (history.length === 0) {
                    allHistoryList.innerHTML = `<li>No hay historial de recomendaciones aún.</li>`;
                    aciertosList.innerHTML = `<li>Ninguno.</li>`;
                    riesgosList.innerHTML = `<li>Ninguno.</li>`;
                    return;
                }

                const tempAllHistory = [];
                const tempAciertos = [];
                const tempRiesgos = [];

                history.forEach(entry => {
                    const date = new Date(entry.timestamp);
                    const timeString = date.toLocaleTimeString('es-AR', { hour: '2-digit', minute: '2-digit' });
                    const dateString = date.toLocaleDateString('es-AR', { day: '2-digit', month: '2-digit' });

                    let recClass = 'action-hold';
                    let recText = 'MANTENER';
                    if (entry.recommendation === 'buy') {
                        recClass = 'action-buy';
                        recText = 'COMPRA';
                    } else if (entry.recommendation === 'sell') {
                        recClass = 'action-sell';
                        recText = 'VENTA';
                    }

                    let metricHtml = '';
                    if (entry.metric_type && entry.metric_type !== 'N/A') {
                        const metricClass = entry.metric_type === 'Acierto' ? 'metric-acierto' : 'metric-riesgo';
                        metricHtml = `<span class="${metricClass}">${entry.metric_type}: <span class="metric-value">${entry.metric_value}%</span></span>`;
                    } else {
                        metricHtml = `<span class="metric-na">N/A</span>`; 
                    }

                    let allHistoryItemHtml = `
                        <span class="opportunity-label">${entry.symbol}</span> 
                        <span class="historical-timestamp">${dateString} ${timeString}</span>
                        <span class="opportunity-action ${recClass}">${recText}</span>
                        <div style="font-size: 0.75em; color: #888; width: 100%; text-align: right;">
                            ${entry.details || ''} 
                        </div>
                    `;
                    tempAllHistory.push({html: allHistoryItemHtml, timestamp: entry.timestamp}); 

                    if (entry.metric_type === 'Acierto') {
                        let aciertoItemHtml = `
                            <span class="opportunity-label">${entry.symbol}</span> 
                            <span class="historical-timestamp">${dateString} ${timeString}</span>
                            ${metricHtml}
                        `;
                        tempAciertos.push({html: aciertoItemHtml, timestamp: entry.timestamp});
                    } else if (entry.metric_type === 'Riesgo') {
                        let riesgoItemHtml = `
                            <span class="opportunity-label">${entry.symbol}</span> 
                            <span class="historical-timestamp">${dateString} ${timeString}</span>
                            ${metricHtml}
                        `;
                        tempRiesgos.push({html: riesgoItemHtml, timestamp: entry.timestamp});
                    }
                });

                tempAllHistory.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).forEach(item => {
                    const li = document.createElement('li');
                    li.innerHTML = item.html;
                    allHistoryList.appendChild(li);
                });
                tempAciertos.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).forEach(item => {
                    const li = document.createElement('li');
                    li.innerHTML = item.html;
                    aciertosList.appendChild(li);
                });
                tempRiesgos.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).forEach(item => {
                    const li = document.createElement('li');
                    li.innerHTML = item.html;
                    riesgosList.appendChild(li);
                });

                if (tempAllHistory.length === 0) allHistoryList.innerHTML = `<li>No hay historial.</li>`;
                if (tempAciertos.length === 0) aciertosList.innerHTML = `<li>Ninguno.</li>`;
                if (tempRiesgos.length === 0) riesgosList.innerHTML = `<li>Ninguno.</li>`;

                console.log(`Historial cargado desde backend. Total: ${history.length} entradas.`);
            } catch (error) {
                console.error('Error al cargar historial desde backend (catch):', error);
                allHistoryList.innerHTML = `<li>Error al cargar: ${error.message}</li>`;
                aciertosList.innerHTML = `<li>Error al cargar.</li>`;
                riesgosList.innerHTML = `<li>Error al cargar.</li>`;
            }
        }

        // ===================================================================================
        // --- LÓGICA PRINCIPAL DE ANÁLISIS (AHORA PIDE DATOS AL BACKEND) ---
        // ===================================================================================

        // runSelectedCryptoAnalysis ahora obtendrá los datos del backend
        async function runSelectedCryptoAnalysis() {
            console.log("Inicio de runSelectedCryptoAnalysis (obteniendo de backend).");
            if (countdownInterval) clearInterval(countdownInterval);

            smaSignalDiv.textContent = 'Cargando...';
            rsiSignalDiv.textContent = 'Cargando...';
            bbSignalDiv.textContent = 'Cargando...';
            smaSignalDiv.className = 'signal hold';
            rsiSignalDiv.className = 'signal hold';
            bbSignalDiv.className = 'signal hold';
            updateTimerDiv.textContent = "";

            priceNoDataMessage.style.display = 'none';
            priceChartCanvas.style.display = 'block';

            const selectedSymbol = coinSelect.value;
            if (!selectedSymbol) {
                console.warn("No hay criptomoneda seleccionada.");
                if (priceChartInstance) priceChartInstance.destroy();
                priceChartCanvas.style.display = 'none'; 
                priceNoDataMessage.textContent = "No hay criptomoneda seleccionada o datos iniciales."
                priceNoDataMessage.style.display = 'flex'; 
                return;
            }
            console.log(`runSelectedCryptoAnalysis: Solicitando análisis de ${selectedSymbol} al backend.`);

            const analysisData = await getLatestAnalysisFromBackend(selectedSymbol); 
            
            if (!analysisData || !analysisData.klines || analysisData.klines.length === 0) {
                console.error(`runSelectedCryptoAnalysis: No se recibieron datos de análisis para ${selectedSymbol} del backend.`);
                smaSignalDiv.textContent = 'Error: No hay datos.';
                rsiSignalDiv.textContent = 'Error: No hay datos.';
                bbSignalDiv.textContent = 'Error: No hay datos.';
                updateTimerDiv.textContent = "Datos no disponibles del backend";
                
                // Aseguramos que los caches sean nulls/vacíos si no hay datos
                currentPriceDataCache = null; 
                currentSmaShortCache = null;
                currentSmaLongCache = null;
                currentBollingerBandsCache = null;
                currentRsiCache = null;

                if (priceChartInstance) priceChartInstance.destroy();
                priceChartCanvas.style.display = 'none';
                priceNoDataMessage.textContent = "Datos no disponibles para gráficos."
                priceNoDataMessage.style.display = 'flex';
                return;
            }

            currentPriceDataCache = analysisData.klines; 
            currentSmaShortCache = analysisData.sma_short;
            currentSmaLongCache = analysisData.sma_long;
            currentBollingerBandsCache = analysisData.bb_bands;
            currentRsiCache = analysisData.rsi_data; 
            
            console.log(`runSelectedCryptoAnalysis: Renderizando gráficos para ${selectedSymbol} con datos del backend.`);
            renderPriceChart(currentPriceDataCache, currentSmaShortCache, currentSmaLongCache, currentBollingerBandsCache, currentRsiCache);
            
            // Actualizar señales individuales con los datos recibidos del backend
            updateSignals(analysisData, null); 
            
            startUpdateTimer(UPDATE_INTERVAL_SELECTED_CRYPTO / 1000);
            console.log("Análisis de criptomoneda seleccionada completado (datos de backend).");
        }

        // updateAllCryptosOpportunities ahora obtendrá las últimas oportunidades del historial
        async function updateAllCryptosOpportunities() {
            console.log("Inicio de updateAllCryptosOpportunities (obteniendo de backend).");
            
            // CAMBIADO: La lógica de poblar las columnas de Oportunidades se basa en la cache del backend.
            // Primero, obtenemos los símbolos que el backend está monitoreando
            let symbolsToDisplay = allCryptos; 
            if (symbolsToDisplay.length === 0) {
                buyList.innerHTML = '<li>No hay criptos.</li>';
                sellList.innerHTML = '<li>No hay criptos.</li>';
                holdList.innerHTML = '<li>No hay criptos.</li>';
                return;
            }

            // Inicializar las listas del tablero de oportunidades
            buyList.innerHTML = '<li>Actualizando...</li>';
            sellList.innerHTML = '<li>Actualizando...</li>';
            holdList.innerHTML = '<li>Actualizando...</li>';

            const tempRecommendations = { buy: [], sell: [], hold: [], error: [] };

            for (const symbol of symbolsToDisplay) {
                // Obtener el análisis más reciente para cada símbolo directamente de la cache del backend
                const analysisData = await getLatestAnalysisFromBackend(symbol); 
                
                if (analysisData && analysisData.overall_rec) {
                    if (analysisData.overall_rec === 'buy') {
                        tempRecommendations.buy.push(symbol);
                    } else if (analysisData.overall_rec === 'sell') {
                        tempRecommendations.sell.push(symbol);
                    } else { // 'hold' o 'N/A'
                        tempRecommendations.hold.push(symbol);
                    }
                } else {
                    // Si no hay datos válidos del backend para este símbolo, lo ponemos en "Hold" con una nota
                    tempRecommendations.hold.push(`${symbol} (Sin datos)`); 
                }
            }
            renderOpportunityColumns(tempRecommendations); // Actualizar el DOM con las oportunidades
            console.log("updateAllCryptosOpportunities: Tablero de oportunidades actualizado.");
        }


        // ===================================================================================
        // --- CÓDIGO DE INICIO Y EVENT LISTENERS ---
        // ===================================================================================

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOM Cargado. Iniciando aplicación.");
            // 1. Cargar la lista dinámica de criptos desde el backend
            await initDynamicCryptoList(); 

            if (allCryptos.length > 0) {
                runSelectedCryptoAnalysis(); 
                updateAllCryptosOpportunities(); // Carga las oportunidades (que es la primera página del historial)
                
                setInterval(runSelectedCryptoAnalysis, UPDATE_INTERVAL_SELECTED_CRYPTO);
                setInterval(updateAllCryptosOpportunities, UPDATE_INTERVAL_ALL_CRYPTOS); 
                setInterval(loadHistoricalRecommendationsFromBackend, HISTORY_UPDATE_INTERVAL); 
            } else {
                console.error("No se encontraron criptomonedas en la lista estática. La aplicación no puede iniciar correctamente.");
                priceNoDataMessage.textContent = "Error: No se encontraron criptomonedas en la lista.";
                priceNoDataMessage.style.display = 'flex';
                renderOpportunityColumns({ buy: [], sell: [], hold: [], error: ['No hay criptos en la lista.'] });
            }
        });

        coinSelect.addEventListener('change', runSelectedCryptoAnalysis);

        const indicatorCheckboxes = document.querySelectorAll('#indicator-selection-panel input[type="checkbox"]');
        indicatorCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                if (currentPriceDataCache) { 
                    renderPriceChart(currentPriceDataCache, currentSmaShortCache, currentSmaLongCache, currentBollingerBandsCache, currentRsiCache);
                } else {
                    console.warn("No hay datos en caché para redibujar el gráfico con los indicadores.");
                }
            });
        });

        // Paginación del historial - Event Listeners
        prevPageBtn.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                loadHistoricalRecommendationsFromBackend();
            }
        });

        nextPageBtn.addEventListener('click', () => {
            if (currentPage < totalPages) {
                currentPage++;
                loadHistoricalRecommendationsFromBackend();
            }
        });

    </script>
</body>
</html>
