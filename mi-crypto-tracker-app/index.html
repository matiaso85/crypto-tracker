<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Tracker Online (Bybit + Backend)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            margin-bottom: 20px;
        }
        .top-section-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 95%;
            max-width: 1200px;
            margin-bottom: 20px;
        }
        #controls {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            flex: 1;
            min-width: 280px;
        }
        #coin-select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: #e0e0e0;
            font-size: 1em;
            width: 100%;
        }
        #update-timer {
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
        }
        #signals-panel {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
            width: 95%;
            max-width: 1200px;
        }
        .signal {
            padding: 15px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            flex-grow: 1;
            min-width: 150px;
        }
        .buy { background-color: #28a745; color: white; }
        .sell { background-color: #dc3545; color: white; }
        .hold { background-color: #6c757d; color: white; }
        .overbought { background-color: #ffc107; color: #121212; }
        .oversold { background-color: #17a2b8; color: white; }
        .alert-buy {
            animation: pulse-buy 1s infinite alternate;
            border: 2px solid #28a745;
        }
        .alert-sell {
            animation: pulse-sell 1s infinite alternate;
            border: 2px solid #dc3545;
        }
        @keyframes pulse-buy {
            from { box-shadow: 0 0 5px #28a745; }
            to { box-shadow: 0 0 20px #28a745; }
        }
        @keyframes pulse-sell {
            from { box-shadow: 0 0 5px #dc3545; }
            to { box-shadow: 0 0 20px #dc3545; }
        }
        .chart-container {
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            margin-top: 20px;
            height: 450px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .no-data-message {
            color: #e0e0e0;
            font-size: 1.5em;
            text-align: center;
        }
        
        #current-opportunities-board {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            flex: 3;
            min-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #current-opportunities-board h2 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 5px;
            text-align: center;
        }
        .opportunity-columns {
            display: flex;
            gap: 10px;
            flex-grow: 1;
            min-height: 200px;
        }
        .opportunity-column {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 6px;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .opportunity-column h3 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            text-align: center;
        }
        .opportunity-column ul {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            overflow-y: auto;
            flex-grow: 1;
        }
        .opportunity-column li {
            background-color: #333;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 1em;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }
        .opportunity-column li:last-child {
            margin-bottom: 0;
        }
        .col-buy li { border-left: 4px solid #28a745; }
        .col-sell li { border-left: 4px solid #dc3545; }
        .col-hold li { border-left: 4px solid #6c757d; }

        #indicator-selection-panel {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            margin-top: 20px;
            width: 95%;
            max-width: 1200px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            align-items: center;
        }
        #indicator-selection-panel div {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #indicator-selection-panel label {
            font-size: 1em;
            color: #e0e0e0;
            cursor: pointer;
        }
        #indicator-selection-panel input[type="checkbox"] {
            transform: scale(1.2);
            cursor: pointer;
        }
        /* NUEVOS ESTILOS PARA LAS 3 COLUMNAS DEL HISTORIAL */
        #backend-historical-board {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            margin-top: 20px;
            width: 95%;
            max-width: 1200px;
            display: flex;
            flex-direction: column; /* Columna para el t칤tulo, luego las sub-columnas */
            gap: 10px;
        }
        #backend-historical-board h2 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 5px;
            text-align: center;
        }
        .history-columns-container { /* Nuevo contenedor para las sub-columnas */
            display: flex;
            gap: 10px;
            flex-grow: 1;
            min-height: 250px; /* Altura m칤nima para que sean visibles */
        }
        .history-column {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 6px;
            flex: 1; /* Hace que cada columna ocupe el mismo espacio */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* Oculta contenido que se desborda para el scrollbar */
        }
        .history-column h3 {
            color: #e0e0e0;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            text-align: center;
        }
        .history-column ul {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            overflow-y: auto; /* Permite scroll individual en cada columna */
            flex-grow: 1;
        }
        .history-column li {
            background-color: #333;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 0.9em; /* Fuente un poco m치s peque침a para m치s entradas */
            display: flex;
            flex-direction: column; /* Apila symbol y timestamp */
            align-items: flex-start; /* Alinea texto a la izquierda en la lista */
            font-weight: bold;
            word-wrap: break-word; /* Para asegurar que el texto largo se ajuste */
        }
        .history-column li:last-child {
            margin-bottom: 0;
        }
        .historical-timestamp {
            font-size: 0.7em; /* Fuente m치s peque침a para el timestamp */
            color: #aaa;
            font-weight: normal;
        }
        .metric-info { /* Contenedor para acierto/riesgo y valor */
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-weight: normal; /* Para que el texto sea normal por defecto */
        }
        /* Estilos para las m칠tricas de acierto/riesgo en el historial */
        .metric-acierto { color: #28a745; font-weight: bold; } /* Verde para acierto */
        .metric-riesgo { color: #dc3545; font-weight: bold; } /* Rojo para riesgo */
        .metric-na { color: #6c757d; } /* Gris para N/A */
        .metric-value { margin-left: 5px; font-size: 0.9em; font-weight: bold;} /* Porcentaje */
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2"></script>
</head>
<body>
    <h1>Crypto Tracker Online (Bybit + Backend)</h1>

    <div class="top-section-container">
        <div id="controls">
            <label for="coin-select">Elige una Criptomoneda:</label>
            <select id="coin-select">
                <option value="BTCUSDT" selected>Bitcoin (BTC/USDT)</option>
                <option value="ETHUSDT">Ethereum (ETH/USDT)</option>
                <option value="BNBUSDT">BNB (BNB/USDT)</option>
                <option value="XRPUSDT">XRP (XRP/USDT)</option>
                <option value="SOLUSDT">Solana (SOL/USDT)</option>
                <option value="ADAUSDT">Cardano (ADA/USDT)</option>
                <option value="DOGEUSDT">Dogecoin (DOGE/USDT)</option>
                <option value="SHIBUSDT">Shiba Inu (SHIB/USDT)</option>
                <option value="DOTUSDT">Polkadot (DOT/USDT)</option>
                <option value="LTCUSDT">Litecoin (LTC/USDT)</option>
                <option value="LINKUSDT">Chainlink (LINK/USDT)</option>
                <option value="MATICUSDT">Polygon (MATIC/USDT)</option>
                <option value="TRXUSDT">Tron (TRX/USDT)</option>
                <option value="AVAXUSDT">Avalanche (AVAX/USDT)</option>
                <option value="UNIUSDT">Uniswap (UNI/USDT)</option>
                <option value="FILUSDT">Filecoin (FIL/USDT)</option>
                <option value="ICPUSDT">Internet Computer (ICP/USDT)</option>
                <option value="APTUSDT">Aptos (APT/USDT)</option>
                <option value="SUIUSDT">Sui (SUI/USDT)</option>
                <option value="NEARUSDT">NEAR Protocol (NEAR/USDT)</option>
                <option value="ATOMUSDT">Cosmos (ATOM/USDT)</option>
                <option value="ARBUSD">Arbitrum (ARB/USDT)</option>
                <option value="OPUSDT">Optimism (OP/USDT)</option>
                <option value="IMXUSDT">Immutable X (IMX/USDT)</option>
                <option value="AAVEUSDT">Aave (AAVE/USDT)</option>
                <option value="ALGOUSDT">Algorand (ALGO/USDT)</option>
                <option value="FTMUSDT">Fantom (FTM/USDT)</option>
                <option value="VETUSDT">VeChain (VET/USDT)</option>
                <option value="CHZUSDT">Chiliz (CHZ/USDT)</option>
                <option value="GRTUSDT">The Graph (GRT/USDT)</option>
                <option value="AXSUSDT">Axie Infinity (AXS/USDT)</option>
                <option value="EOSUSDT">EOS (EOS/USDT)</option>
                <option value="KLAYUSDT">Klaytn (KLAY/USDT)</option>
                <option value="SANDUSDT">The Sandbox (SAND/USDT)</option>
                <option value="MANAUSDT">Decentraland (MANA/USDT)</option>
                </select>
            <div id="update-timer"></div>
            <p style="font-size: 0.8em; color: #888; margin-top: 10px;">
                Selecciona una criptomoneda para ver su an치lisis detallado (gr치ficos y se침ales individuales).
            </p>
        </div>

        <div id="current-opportunities-board">
            <h2>Oportunidades de Trading (Todas las Criptos)</h2>
            <div class="opportunity-columns">
                <div class="opportunity-column col-buy">
                    <h3>COMPRA</h3>
                    <ul id="buy-list">
                        <li>Cargando...</li> 
                    </ul>
                </div>
                <div class="opportunity-column col-sell">
                    <h3>VENTA</h3>
                    <ul id="sell-list">
                        <li>Cargando...</li>
                    </ul>
                </div>
                <div class="opportunity-column col-hold">
                    <h3>MANTENER</h3>
                    <ul id="hold-list">
                        <li>Cargando...</li>
                    </ul>
                </div>
            </div>
            <p style="font-size: 0.8em; color: #888; margin-top: 10px; text-align: center;">
                Recomendaciones basadas en an치lisis t칠cnico (SMA, RSI, BB) para todas las criptomonedas listadas.
                La actualizaci칩n de esta secci칩n se realiza progresivamente.
            </p>
        </div>
    </div>

    <div id="indicator-selection-panel" class="container">
        <div>
            <input type="checkbox" id="toggle-sma-short" checked>
            <label for="toggle-sma-short">SMA Corta</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-sma-long" checked>
            <label for="toggle-sma-long">SMA Larga</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-bb-upper" checked>
            <label for="toggle-bb-upper">BB Superior</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-bb-middle" checked>
            <label for="toggle-bb-middle">BB Media</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-bb-lower" checked>
            <label for="toggle-bb-lower">BB Inferior</label>
        </div>
        <div>
            <input type="checkbox" id="toggle-rsi" checked>
            <label for="toggle-rsi">RSI</label>
        </div>
    </div>

    <div id="signals-panel" class="container">
        <div id="sma-signal" class="signal hold">Cargando...</div>
        <div id="rsi-signal" class="signal hold">Cargando...</div>
        <div id="bb-signal" class="signal hold">Cargando...</div>
    </div>
    
    <div id="price-chart-container" class="chart-container container">
        <canvas id="priceChart"></canvas>
        <div id="price-no-data" class="no-data-message" style="display:none;">No hay datos para mostrar el gr치fico de precios.</div>
    </div>
    
    <div id="backend-historical-board" class="container">
        <h2>Historial de Recomendaciones (Desde Backend)</h2>
        <div class="history-columns-container"> <div class="history-column">
                <h3>Todas las Criptos</h3>
                <ul id="all-history-list">
                    <li>Cargando...</li>
                </ul>
            </div>
            <div class="history-column">
                <h3>Aciertos</h3>
                <ul id="aciertos-list">
                    <li>Cargando...</li>
                </ul>
            </div>
            <div class="history-column">
                <h3>Riesgos</h3>
                <ul id="riesgos-list">
                    <li>Cargando...</li>
                </ul>
            </div>
        </div>
        <p style="font-size: 0.8em; color: #888; margin-top: 10px; text-align: center;">
            Este historial se guarda y recupera desde el servidor backend (archivo data.csv).
        </p>
    </div>

    <script>
        // ===================================================================================
        // --- CONFIGURACI칍N E INICIALIZACI칍N ---
        // ===================================================================================

        // URL BASE DE TU BACKEND (춰IMPORTANTE: Cambiar esto cuando lo publiques!)
        // Durante el desarrollo local, usa 'http://172.0.0.1:5000'
        // Despu칠s de publicar en Render, usa la URL que Render te d칠 (ej. 'https://tu-backend-nombre.onrender.com')
        const BACKEND_URL = 'https://crypto-tracker-ukyl.onrender.com'; 

        const BYBIT_INTERVAL = "60"; 
        const BYBIT_CATEGORY = "spot";
        const BYBIT_LIMIT = 200; 

        const UPDATE_INTERVAL_SELECTED_CRYPTO = 120000; // 2 minutos para actualizar la crypto seleccionada
        const UPDATE_INTERVAL_ALL_CRYPTOS = 5 * 60 * 1000; // 5 minutos para actualizar TODAS las oportunidades
        const ALL_CRYPTOS_API_DELAY = 1500; // 1.5 segundos de retraso entre cada crypto para la API
        const HISTORY_UPDATE_INTERVAL = 60000; // 1 minuto para actualizar el historial
        // NUEVO: Intervalo para guardar la recomendaci칩n en el backend (1 hora = 3600000 ms)
        const SAVE_REC_TO_BACKEND_INTERVAL = 3600000; // 1 hora
        // NUEVO: Umbral de cambio de precio para guardar una recomendaci칩n (3%)
        const PRICE_CHANGE_THRESHOLD = 0.03; // 3%

        // Map para guardar la 칰ltima vez que se guard칩 una recomendaci칩n y su precio asociado por s칤mbolo
        // Estructura: Map<symbol, {timestamp: number, price: number}>
        const lastSavedData = new Map();


        const SMA_SHORT_PERIOD = 20;
        const SMA_LONG_PERIOD = 50;
        const BB_PERIOD = 20;
        const BB_STD_DEV = 2;
        const RSI_PERIOD = 14;
        const RSI_OVERBOUGHT = 70;
        const RSI_OVERSOLD = 30;

        const coinSelect = document.getElementById('coin-select');
        const updateTimerDiv = document.getElementById('update-timer');
        const smaSignalDiv = document.getElementById('sma-signal');
        const rsiSignalDiv = document.getElementById('rsi-signal');
        const bbSignalDiv = document.getElementById('bb-signal');
        
        const buyList = document.getElementById('buy-list');
        const sellList = document.getElementById('sell-list');
        const holdList = document.getElementById('hold-list');

        const priceChartCanvas = document.getElementById('priceChart');
        const priceNoDataMessage = document.getElementById('price-no-data');

        const toggleSmaShort = document.getElementById('toggle-sma-short');
        const toggleSmaLong = document.getElementById('toggle-sma-long');
        const toggleBbUpper = document.getElementById('toggle-bb-upper');
        const toggleBbMiddle = document.getElementById('toggle-bb-middle');
        const toggleBbLower = document.getElementById('toggle-bb-lower');
        const toggleRsi = document.getElementById('toggle-rsi');

        // Referencias a las nuevas listas de historial
        const allHistoryList = document.getElementById('all-history-list');
        const aciertosList = document.getElementById('aciertos-list');
        const riesgosList = document.getElementById('riesgos-list');

        let priceChartInstance, countdownInterval;
        let isProcessingAllCryptos = false;

        let allCryptos = []; 

        let currentPriceDataCache = null;
        let currentSmaShortCache = null;
        let currentSmaLongCache = null;
        let currentBollingerBandsCache = null;
        let currentRsiCache = null; 

        // ===================================================================================
        // --- INICIALIZACI칍N DE LA APLICACI칍N ---
        // ===================================================================================

        function initStaticCryptoList() {
            allCryptos = [];
            const options = coinSelect.options;
            if (options.length === 0) {
                console.error("Error: No se encontraron opciones en el selector de criptomonedas. Aseg칰rate de que el HTML est칠 cargado correctamente.");
                return;
            }
            for (let i = 0; i < options.length; i++) {
                allCryptos.push(options[i].value);
            }
            console.log("Lista de criptomonedas est치tica cargada. Total:", allCryptos.length);
        }

        // ===================================================================================
        // --- FUNCIONES DE C츼LCULO DE INDICADORES ---
        // DEBEN estar definidas antes de ser llamadas.
        // ===================================================================================
        function calculateSMA(data, period) {
            let sma = [];
            if (!data || data.length < period) return Array(data ? data.length : 0).fill(null); 

            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    sma.push(null);
                } else {
                    const slice = data.slice(i - period + 1, i + 1);
                    const sum = slice.reduce((acc, val) => acc + val, 0);
                    sma.push({ y: sum / period });
                }
            }
            return sma;
        }

        function calculateBollingerBands(data, period, stdDevMultiplier) {
            let middle = [], upper = [], lower = [];
            if (!data || data.length < period) { 
                const nulls = Array(data ? data.length : 0).fill(null);
                return { middle: nulls, upper: nulls, lower: nulls };
            }

            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    middle.push(null);
                    upper.push(null);
                    lower.push(null);
                } else {
                    const slice = data.slice(i - period + 1, i + 1);
                    const mean = slice.reduce((acc, val) => acc + val, 0) / period;
                    const stdDev = Math.sqrt(slice.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / period);
                    
                    middle.push({ y: mean });
                    upper.push({ y: mean + (stdDev * stdDevMultiplier) });
                    lower.push({ y: mean - (stdDev * stdDevMultiplier) });
                }
            }
            return { middle, upper, lower };
        }

        function calculateRSI(data, period) {
            let rsiValues = [];
            
            if (!data || data.length < period + 1) { 
                return Array(data ? data.length : 0).fill(null);
            }

            for (let i = 0; i < period; i++) {
                rsiValues.push(null);
            }

            let avgGain = 0;
            let avgLoss = 0;

            for (let i = 1; i <= period; i++) {
                const diff = data[i] - data[i - 1];
                if (diff > 0) {
                    avgGain += diff;
                } else {
                    avgLoss += Math.abs(diff);
                }
            }
            avgGain /= period;
            avgLoss /= period;

            if (avgLoss === 0) {
                rsiValues.push({ y: 100 });
            } else {
                const rs = avgGain / avgLoss;
                rsiValues.push({ y: 100 - (100 / (1 + rs)) });
            }

            for (let i = period + 1; i < data.length; i++) {
                const diff = data[i] - data[i - 1];
                let currentGain = diff > 0 ? diff : 0;
                let currentLoss = diff < 0 ? Math.abs(diff) : 0;

                avgGain = ((avgGain * (period - 1)) + currentGain) / period;
                avgLoss = ((avgLoss * (period - 1)) + currentLoss) / period;

                if (avgLoss === 0) {
                    rsiValues.push({ y: 100 });
                } else {
                    const rs = avgGain / avgLoss;
                    rsiValues.push({ y: 100 - (100 / (1 + rs)) });
                }
            }
            return rsiValues;
        }

        // ===================================================================================
        // --- FUNCIONES DE OBTENCI칍N DE DATOS (BYBIT API) ---
        // DEBEN estar definidas antes de las funciones de an치lisis principal.
        // ===================================================================================
        async function getCryptoData(symbol, interval = "60", category = "spot", limit = 200) {
            const url = `https://api.bybit.com/v5/market/kline?category=${category}&symbol=${symbol}&interval=${interval}&limit=${limit}`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`Error de red de Bybit para ${symbol}: ${response.status} - ${response.statusText}. Detalles: ${errorDetails.substring(0, Math.min(errorDetails.length, 200))}...`);
                }
                
                const data = await response.json();
                
                if (!data || !data.result || !data.result.list || data.result.list.length === 0) {
                    throw new Error(`La API de Bybit para ${symbol} devolvi칩 una respuesta v치lida pero sin datos de klines.`);
                }
                
                const formattedPrices = data.result.list.map(kline => ({
                    x: parseInt(kline[0]),
                    y: parseFloat(kline[4])
                }));

                return formattedPrices.reverse(); 

            } catch (error) {
                console.error(`Error al obtener datos de la API de Bybit para ${symbol}:`, error);
                return null; 
            }
        }
        
        // ===================================================================================
        // --- FUNCIONES DE RENDERING Y ACTUALIZACI칍N DE PANELES ---
        // DEBEN estar definidas ANTES de ser llamadas por runSelectedCryptoAnalysis o updateAllCryptosOpportunities
        // ===================================================================================

        /**
         * Dibuja o actualiza el gr치fico principal de precios, y los indicadores seleccionados.
         * @param {Array<object>} priceData - Datos de precio en formato { x: timestamp, y: price }.
         * @param {Array<object|null>} smaShort - Datos de la SMA corta.
         * @param {Array<object|null>} smaLong - Datos de la SMA larga.
         * @param {object} bb - Objeto con datos de Bandas de Bollinger (upper, middle, lower).
         * @param {Array<object|null>} rsi - Datos del RSI.
         */
        function renderPriceChart(priceData, smaShort, smaLong, bb, rsi) {
            console.log("renderPriceChart: Iniciando renderizado del gr치fico."); 
            if (priceChartInstance) priceChartInstance.destroy();

            const ctx = priceChartCanvas.getContext('2d');
            const datasets = [
                { 
                    label: 'Precio (USD)', 
                    data: priceData, 
                    borderColor: '#36a2eb', 
                    borderWidth: 2.5, 
                    pointRadius: 0, 
                    tension: 0.1, 
                    fill: false,
                    yAxisID: 'y-price' 
                }
            ];

            if (toggleSmaShort.checked) {
                console.log("renderPriceChart: Agregando SMA Corta."); 
                datasets.push({ 
                    label: `SMA ${SMA_SHORT_PERIOD}`, 
                    data: smaShort.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), 
                    borderColor: '#ffce56', 
                    borderWidth: 1.5, 
                    pointRadius: 0, 
                    fill: false,
                    yAxisID: 'y-price' 
                });
            }
            if (toggleSmaLong.checked) {
                console.log("renderPriceChart: Agregando SMA Larga."); 
                datasets.push({ 
                    label: `SMA ${SMA_LONG_PERIOD}`, 
                    data: smaLong.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), 
                    borderColor: '#ff6384', 
                    borderWidth: 1.5, 
                    pointRadius: 0, 
                    fill: false,
                    yAxisID: 'y-price' 
                });
            }
            
            if (toggleBbUpper.checked) {
                console.log("renderPriceChart: Agregando BB Superior."); 
                datasets.push({ 
                    label: `BB Superior`, 
                    data: bb.upper.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), 
                    borderColor: 'rgba(153, 102, 255, 0.5)', 
                    borderWidth: 1, 
                    pointRadius: 0, 
                    fill: false,
                    yAxisID: 'y-price' 
                });
            }
            if (toggleBbLower.checked) {
                console.log("renderPriceChart: Agregando BB Inferior."); 
                datasets.push({ 
                    label: `BB Inferior`, 
                    data: bb.lower.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), 
                    borderColor: 'rgba(153, 102, 255, 0.5)', 
                    borderWidth: 1, 
                    pointRadius: 0, 
                    fill: '-1',
                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                    hidden: false,
                    yAxisID: 'y-price' 
                });
            }
            if (toggleBbMiddle.checked) {
                console.log("renderPriceChart: Agregando BB Media."); 
                datasets.push({ 
                    label: `BB Media`, 
                    data: bb.middle.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null), 
                    borderColor: 'rgba(153, 102, 255, 0.8)', 
                    borderWidth: 1.5, 
                    pointRadius: 0, 
                    borderDash: [5, 5], 
                    fill: false,
                    yAxisID: 'y-price' 
                });
            }

            if (toggleRsi.checked) {
                console.log("renderPriceChart: Agregando RSI."); 
                datasets.push({
                    label: `RSI (${RSI_PERIOD})`,
                    data: rsi.map((val, i) => val ? { x: priceData[i].x, y: val.y } : null),
                    borderColor: '#4bc0c0', 
                    borderWidth: 1.5,
                    pointRadius: 0,
                    fill: false,
                    yAxisID: 'y-rsi' 
                });
            }

            // Configuraci칩n de anotaciones para el RSI (condicional a toggleRsi.checked)
            const annotations = {};
            if (toggleRsi.checked) {
                annotations.rsiOverboughtLine = { 
                    type: 'line', 
                    yMin: RSI_OVERBOUGHT, 
                    yMax: RSI_OVERBOUGHT, 
                    borderColor: 'red', 
                    borderWidth: 1, 
                    borderDash: [5, 5], 
                    yAxisID: 'y-rsi', 
                    label: { 
                        content: 'Sobrecompra', enabled: true, position: 'start', 
                        color: '#e0e0e0', backgroundColor: 'rgba(255, 0, 0, 0.5)'
                    } 
                };
                annotations.rsiOversoldLine = { 
                    type: 'line', 
                    yMin: RSI_OVERSOLD, 
                    yMax: RSI_OVERSOLD, 
                    borderColor: 'green', 
                    borderWidth: 1, 
                    borderDash: [5, 5], 
                    yAxisID: 'y-rsi', 
                    label: { 
                        content: 'Sobreventa', enabled: true, position: 'start', 
                        color: '#e0e0e0', backgroundColor: 'rgba(0, 128, 0, 0.5)'
                    } 
                };
            }


            priceChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: { 
                            type: 'time', 
                            time: { 
                                unit: 'hour', 
                                tooltipFormat: 'HH:mm dd/MM/yy',
                                displayFormats: {
                                    hour: 'HH:mm',
                                    day: 'dd/MM'
                                }
                            },
                            title: { display: true, text: 'Fecha/Hora', color: '#e0e0e0' },
                            ticks: { color: '#e0e0e0' },
                            grid: { color: '#333' }
                        },
                        'y-price': { 
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Precio (USD)', color: '#e0e0e0' },
                            ticks: { color: '#e0e0e0' },
                            grid: { color: '#333' }
                        },
                        'y-rsi': { 
                            type: 'linear',
                            display: toggleRsi.checked, 
                            position: 'right',
                            min: 0,
                            max: 100,
                            title: { display: true, text: 'RSI', color: '#4bc0c0' },
                            ticks: { color: '#4bc0c0' },
                            grid: { drawOnChartArea: false } 
                        }
                    },
                    plugins: {
                        tooltip: { mode: 'index', intersect: false },
                        legend: { labels: { color: '#e0e0e0' } },
                        annotation: {
                            annotations: annotations 
                        }
                    }
                }
            });
            console.log("Gr치fico de precios con indicadores renderizado.");
        }
        
        function updateSignals(smaShort, smaLong, rsi, bollingerBands, closingPrices) {
            smaSignalDiv.classList.remove('alert-buy', 'alert-sell');
            rsiSignalDiv.classList.remove('alert-buy', 'alert-sell');
            bbSignalDiv.classList.remove('alert-buy', 'alert-sell');

            let smaRec = 'hold';
            let rsiRec = 'hold';
            let bbRec = 'hold';

            const validSmaShort = smaShort ? smaShort.filter(v => v !== null) : []; 
            const validSmaLong = smaLong ? smaLong.filter(v => v !== null) : [];  

            if (validSmaShort.length >= 2 && validSmaLong.length >= 2) {
                const lastSmaShort = validSmaShort[validSmaShort.length - 1].y;
                const prevSmaShort = validSmaShort[validSmaShort.length - 2].y;
                const lastSmaLong = validSmaLong[validSmaLong.length - 1].y;
                const prevSmaLong = validSmaLong[validSmaLong.length - 2].y;

                if (prevSmaShort <= prevSmaLong && lastSmaShort > lastSmaLong) {
                    smaSignalDiv.textContent = 'Cruce SMA: COMPRA 游늳 (Corto > Largo)';
                    smaSignalDiv.className = 'signal buy alert-buy';
                } else if (prevSmaShort >= prevSmaLong && lastSmaShort < lastSmaLong) {
                    smaSignalDiv.textContent = 'Cruce SMA: VENTA 游늴 (Corto < Largo)';
                    smaSignalDiv.className = 'signal sell alert-sell';
                } else {
                    smaSignalDiv.textContent = 'Cruce SMA: Mantener 游땛';
                    smaSignalDiv.className = 'signal hold';
                }
            } else {
                smaSignalDiv.textContent = 'Cruce SMA: Datos insuficientes';
                smaSignalDiv.className = 'signal hold';
            }

            const validRsi = rsi ? rsi.filter(v => v !== null) : []; 
            if (validRsi.length > 0) {
                const lastRsi = validRsi[validRsi.length - 1].y;
                if (lastRsi > RSI_OVERBOUGHT) {
                    rsiSignalDiv.textContent = `RSI (${lastRsi.toFixed(1)}): Sobrecompra 丘멆잺`;
                    rsiSignalDiv.className = 'signal overbought alert-sell';
                } else if (lastRsi < RSI_OVERSOLD) {
                    rsiSignalDiv.textContent = `RSI (${lastRsi.toFixed(1)}): Sobreventa 九`;
                    rsiSignalDiv.className = 'signal oversold alert-buy';
                } else {
                    rsiSignalDiv.textContent = `RSI (${lastRsi.toFixed(1)}): Neutral 丘뒲잺`;
                    rsiSignalDiv.className = 'signal hold';
                }
            } else {
                rsiSignalDiv.textContent = 'RSI: Datos insuficientes';
                rsiSignalDiv.className = 'signal hold';
            }

            const validBbUpper = (bollingerBands && bollingerBands.upper) ? bollingerBands.upper.filter(v => v !== null) : []; 
            const validBbLower = (bollingerBands && bollingerBands.lower) ? bollingerBands.lower.filter(v => v !== null) : []; 
            const lastPrice = closingPrices ? closingPrices[closingPrices.length - 1] : undefined; 

            if (validBbUpper.length > 0 && validBbLower.length > 0 && lastPrice !== undefined) {
                const lastBbUpper = validBbUpper[validBbUpper.length - 1].y;
                const lastBbLower = validBbLower[validBbLower.length - 1].y;
                
                if (lastPrice > lastBbUpper) {
                    bbSignalDiv.textContent = `BB: Precio sobre banda superior 拘勇 (Venta)`;
                    bbSignalDiv.className = 'signal sell alert-sell';
                } else if (lastPrice < lastBbLower) {
                    bbSignalDiv.textContent = `BB: Precio bajo banda inferior 拘勇 (Compra)`;
                    bbSignalDiv.className = 'signal buy alert-buy';
                } else {
                    bbSignalDiv.textContent = 'BB: Precio dentro de la banda 游댃';
                    bbSignalDiv.className = 'signal hold';
                }
            } else {
                bbSignalDiv.textContent = 'BB: Datos insuficientes';
                bbSignalDiv.className = 'signal hold';
            }
            console.log("Se침ales individuales actualizadas.");
        }
        
        /**
         * Funci칩n central para renderizar las 3 columnas de oportunidades en el DOM.
         * Se llama repetidamente durante la carga progresiva.
         * @param {object} recommendationsMap - Un objeto con arrays de s칤mbolos para 'buy', 'sell', 'hold', 'error'.
         */
        function renderOpportunityColumns(recommendationsMap) {
            buyList.innerHTML = '';
            sellList.innerHTML = '';
            holdList.innerHTML = '';

            const hasData = recommendationsMap.buy.length > 0 || recommendationsMap.sell.length > 0 || recommendationsMap.hold.length > 0 || recommendationsMap.error.length > 0;
            
            if (!hasData && isProcessingAllCryptos) {
                 buyList.innerHTML = '<li>Cargando...</li>';
                 sellList.innerHTML = '<li>Cargando...</li>';
                 holdList.innerHTML = '<li>Cargando...</li>';
                 return;
            }

            recommendationsMap.buy.sort().forEach(symbol => {
                const li = document.createElement('li');
                li.textContent = symbol;
                buyList.appendChild(li);
            });
            if (recommendationsMap.buy.length === 0 && hasData) buyList.innerHTML = '<li>Ninguna</li>';


            recommendationsMap.sell.sort().forEach(symbol => {
                const li = document.createElement('li');
                li.textContent = symbol;
                sellList.appendChild(li);
            });
            if (recommendationsMap.sell.length === 0 && hasData) sellList.innerHTML = '<li>Ninguna</li>';


            const allHoldSymbols = [...recommendationsMap.hold, ...recommendationsMap.error];
            allHoldSymbols.sort().forEach(symbol => {
                const li = document.createElement('li');
                li.textContent = symbol;
                holdList.appendChild(li);
            });
            if (allHoldSymbols.length === 0 && hasData) holdList.innerHTML = '<li>Ninguna</li>';

            if (!hasData && !isProcessingAllCryptos) {
                buyList.innerHTML = '<li>Error al cargar cryptos.</li>';
                sellList.innerHTML = '<li>Error al cargar cryptos.</li>';
                holdList.innerHTML = '<li>Error al cargar cryptos.</li>';
            }
        }

        function startUpdateTimer(seconds) {
            let remaining = seconds;
            updateTimerDiv.textContent = `Pr칩xima actualizaci칩n de gr치ficos en ${remaining}s...`;
            countdownInterval = setInterval(() => {
                remaining--;
                if (remaining >= 0) {
                    updateTimerDiv.textContent = `Pr칩xima actualizaci칩n de gr치ficos en ${remaining}s...`;
                }
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        // ===================================================================================
        // --- FUNCIONES DE PERSISTENCIA (INTERACCI칍N CON BACKEND) ---
        // DEBEN estar definidas antes de las funciones de an치lisis principal.
        // ===================================================================================

        async function saveRecommendationToBackend(symbol, recommendation, individualSignals, currentPrice) { // Nuevo par치metro currentPrice
            // Aseguramos que la recomendaci칩n no sea undefined o null antes de enviar
            if (recommendation === undefined || recommendation === null) {
                console.warn(`saveRecommendationToBackend: No se pudo guardar la recomendaci칩n para ${symbol} porque es undefined/null.`);
                return; 
            }

            // NUEVO: L칩gica condicional para guardar basada en tiempo O cambio de precio
            const now = Date.now();
            const savedDataForSymbol = lastSavedData.get(symbol); 
            const lastSavedTimestamp = savedDataForSymbol ? savedDataForSymbol.timestamp : 0;
            const lastSavedPrice = savedDataForSymbol ? savedDataForSymbol.price : null;

            const hasTimePassed = (now - lastSavedTimestamp) >= SAVE_REC_TO_BACKEND_INTERVAL;
            
            let hasSignificantPriceChange = false;
            if (lastSavedPrice !== null && currentPrice !== undefined && currentPrice !== null && currentPrice !== 0) {
                const percentageChange = Math.abs(currentPrice - lastSavedPrice) / lastSavedPrice;
                hasSignificantPriceChange = percentageChange >= PRICE_CHANGE_THRESHOLD;
            } else if (lastSavedPrice === null && currentPrice !== undefined && currentPrice !== null) {
                // Si es la primera vez que guardamos un precio, consideramos que hay un "cambio" si ya hay un precio actual.
                // Esto es para que la primera entrada siempre se guarde (si no ha pasado suficiente tiempo).
                hasSignificantPriceChange = true; 
            }


            // Condici칩n para SALTAR el guardado
            if (!hasTimePassed && !hasSignificantPriceChange) {
                console.log(`saveRecommendationToBackend: Saltando guardado para ${symbol}. No ha pasado 1 hora Y no hubo cambio de precio del ${PRICE_CHANGE_THRESHOLD * 100}%.`);
                return;
            }

            // Si llegamos aqu칤, es porque se debe guardar. Actualizar lastSavedData.
            lastSavedData.set(symbol, { timestamp: now, price: currentPrice });


            const payload = {
                symbol: symbol,
                recommendation: recommendation,
                timestamp: new Date().toISOString(),
                sma_rec: individualSignals.sma,
                rsi_rec: individualSignals.rsi,
                bb_rec: individualSignals.bb,
                current_price: currentPrice // NUEVO: Enviar el precio actual al backend
            };
            console.log("Enviando a backend para guardar:", `${BACKEND_URL}/save_recommendation`, payload);
            try {
                const response = await fetch(`${BACKEND_URL}/save_recommendation`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Error HTTP al guardar en backend: ${response.status} - ${response.statusText}. Detalles: ${errorText}`);
                }
                const result = await response.json();
                console.log('Recomendaci칩n guardada en backend:', result.message);
            } catch (error) {
                console.error('Error al guardar recomendaci칩n en backend (catch):', error);
            }
        }

        async function loadHistoricalRecommendationsFromBackend() {
            // Limpiar todas las listas del historial
            allHistoryList.innerHTML = '<li>Cargando historial...</li>';
            aciertosList.innerHTML = '<li>Cargando...</li>';
            riesgosList.innerHTML = '<li>Cargando...</li>';

            console.log("Cargando historial desde backend:", `${BACKEND_URL}/get_recommendations`);
            try {
                const response = await fetch(`${BACKEND_URL}/get_recommendations`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Error HTTP al cargar historial desde backend: ${response.status} - ${response.statusText}. Detalles: ${errorText}`);
                }
                const history = await response.json();

                // Limpiar despu칠s de cargar (si hay datos) o mantener el "Cargando..." si falla el fetch.
                allHistoryList.innerHTML = '';
                aciertosList.innerHTML = '';
                riesgosList.innerHTML = '';

                if (history.length === 0) {
                    allHistoryList.innerHTML = `<li>No hay historial de recomendaciones a칰n.</li>`;
                    aciertosList.innerHTML = `<li>Ninguno.</li>`;
                    riesgosList.innerHTML = `<li>Ninguno.</li>`;
                    return;
                }

                // Arrays temporales para construir las listas ordenadas
                const tempAllHistory = [];
                const tempAciertos = [];
                const tempRiesgos = [];

                history.forEach(entry => {
                    const date = new Date(entry.timestamp);
                    const timeString = date.toLocaleTimeString('es-AR', { hour: '2-digit', minute: '2-digit' });
                    const dateString = date.toLocaleDateString('es-AR', { day: '2-digit', month: '2-digit' });

                    let recClass = 'action-hold';
                    let recText = 'MANTENER';
                    if (entry.recommendation === 'buy') {
                        recClass = 'action-buy';
                        recText = 'COMPRA';
                    } else if (entry.recommendation === 'sell') {
                        recClass = 'action-sell';
                        recText = 'VENTA';
                    }

                    let metricHtml = '';
                    if (entry.metric_type && entry.metric_type !== 'N/A') {
                        const metricClass = entry.metric_type === 'Acierto' ? 'metric-acierto' : 'metric-riesgo';
                        metricHtml = `<span class="${metricClass}">${entry.metric_type}: <span class="metric-value">${entry.metric_value}%</span></span>`;
                    } else {
                        metricHtml = `<span class="metric-na">N/A</span>`; 
                    }

                    // --- Para la columna "Todas las Criptos" ---
                    let allHistoryItemHtml = `
                        <div class="opportunity-item">
                            <span class="opportunity-label">${entry.symbol}</span> 
                            <span class="historical-timestamp">${dateString} ${timeString}</span>
                            <span class="opportunity-action ${recClass}">${recText}</span>
                        </div>
                        <div style="font-size: 0.75em; color: #888; width: 100%; text-align: right;">
                            ${entry.details || ''} 
                        </div>
                    `;
                    tempAllHistory.push({html: allHistoryItemHtml, timestamp: entry.timestamp}); 

                    // --- Para las columnas "Aciertos" y "Riesgos" (solo si aplica) ---
                    if (entry.metric_type === 'Acierto') {
                        let aciertoItemHtml = `
                            <div class="opportunity-item">
                                <span class="opportunity-label">${entry.symbol}</span> 
                                <span class="historical-timestamp">${dateString} ${timeString}</span>
                                ${metricHtml}
                            </div>
                        `;
                        tempAciertos.push({html: aciertoItemHtml, timestamp: entry.timestamp});
                    } else if (entry.metric_type === 'Riesgo') {
                        let riesgoItemHtml = `
                            <div class="opportunity-item">
                                <span class="opportunity-label">${entry.symbol}</span> 
                                <span class="historical-timestamp">${dateString} ${timeString}</span>
                                ${metricHtml}
                            </div>
                        `;
                        tempRiesgos.push({html: riesgoItemHtml, timestamp: entry.timestamp});
                    }
                });

                // Ordenar las listas por timestamp (m치s recientes primero) antes de agregarlas al DOM
                tempAllHistory.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).forEach(item => {
                    const li = document.createElement('li');
                    li.innerHTML = item.html;
                    allHistoryList.appendChild(li);
                });
                tempAciertos.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).forEach(item => {
                    const li = document.createElement('li');
                    li.innerHTML = item.html;
                    aciertosList.appendChild(li);
                });
                tempRiesgos.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).forEach(item => {
                    const li = document.createElement('li');
                    li.innerHTML = item.html;
                    riesgosList.appendChild(li);
                });

                // Si una columna queda vac칤a, mostrar "Ninguno"
                if (tempAllHistory.length === 0) allHistoryList.innerHTML = `<li>No hay historial.</li>`;
                if (tempAciertos.length === 0) aciertosList.innerHTML = `<li>Ninguno.</li>`;
                if (tempRiesgos.length === 0) riesgosList.innerHTML = `<li>Ninguno.</li>`;

                console.log(`Historial cargado desde backend. Total: ${history.length} entradas.`);
            } catch (error) {
                console.error('Error al cargar historial desde backend (catch):', error);
                allHistoryList.innerHTML = `<li>Error al cargar: ${error.message}</li>`;
                aciertosList.innerHTML = `<li>Error al cargar.</li>`;
                riesgosList.innerHTML = `<li>Error al cargar.</li>`;
            }
        }

        // ===================================================================================
        // --- L칍GICA PRINCIPAL DE AN츼LISIS ---
        // Estas funciones deben estar al final o al menos despu칠s de todas las utilidades que llaman.
        // ===================================================================================

        async function runSelectedCryptoAnalysis() {
            console.log("Inicio de runSelectedCryptoAnalysis.");
            if (countdownInterval) clearInterval(countdownInterval);

            smaSignalDiv.textContent = 'Cargando...';
            rsiSignalDiv.textContent = 'Cargando...';
            bbSignalDiv.textContent = 'Cargando...';
            smaSignalDiv.className = 'signal hold';
            rsiSignalDiv.className = 'signal hold';
            bbSignalDiv.className = 'signal hold';
            updateTimerDiv.textContent = "";

            priceNoDataMessage.style.display = 'none';
            priceChartCanvas.style.display = 'block';

            const selectedSymbol = coinSelect.value;
            if (!selectedSymbol) {
                console.warn("No hay criptomoneda seleccionada para el an치lisis detallado (o la lista est치 vac칤a).");
                if (priceChartInstance) priceChartInstance.destroy();
                priceChartCanvas.style.display = 'none'; 
                priceNoDataMessage.textContent = "No hay criptomoneda seleccionada o datos iniciales."
                priceNoDataMessage.style.display = 'flex'; 
                return;
            }
            console.log(`runSelectedCryptoAnalysis: Obteniendo datos de Bybit para: ${selectedSymbol}`);

            const prices = await getCryptoData(selectedSymbol, BYBIT_INTERVAL, BYBIT_CATEGORY, BYBIT_LIMIT);
            
            const minRequiredData = Math.max(SMA_LONG_PERIOD, BB_PERIOD, RSI_PERIOD);
            if (!prices || prices.length < minRequiredData) {
                console.error(`runSelectedCryptoAnalysis: Datos insuficientes para calcular indicadores de ${selectedSymbol}. Se necesitan al menos ${minRequiredData} puntos, se obtuvieron ${prices ? prices.length : 0}.`, prices);
                smaSignalDiv.textContent = 'Error: Datos insuficientes.';
                rsiSignalDiv.textContent = 'Error: Datos insuficientes.';
                bbSignalDiv.textContent = 'Error: Datos insuficientes.';
                updateTimerDiv.textContent = "Datos insuficientes para indicadores";
                
                // Aseguramos que currentPriceDataCache y otros caches sean nulls/vac칤os si no hay datos
                currentPriceDataCache = [];
                currentSmaShortCache = [];
                currentSmaLongCache = [];
                currentBollingerBandsCache = {middle:[], upper:[], lower:[]};
                currentRsiCache = [];

                if (priceChartInstance) priceChartInstance.destroy();
                priceChartCanvas.style.display = 'none';
                priceNoDataMessage.textContent = "Datos insuficientes para gr치ficos."
                priceNoDataMessage.style.display = 'flex';
                // Si no hay datos suficientes, se guarda una recomendaci칩n 'hold' para registrar el evento
                console.log("runSelectedCryptoAnalysis: Guardando 'HOLD' por datos insuficientes.");
                await saveRecommendationToBackend(selectedSymbol, 'hold', {sma: 'N/A', rsi: 'N/A', bb: 'N/A'}, prices && prices.length > 0 ? prices[prices.length -1].y : null); // Se pasa null si no hay precio
                return;
            }

            console.log(`runSelectedCryptoAnalysis: Datos recibidos para ${selectedSymbol}. N칰mero de puntos: ${prices.length}`);

            currentPriceDataCache = prices; 
            const closingPrices = prices.map(p => p.y);
            const currentPrice = closingPrices[closingPrices.length - 1]; // Obtener el 칰ltimo precio de cierre

            console.log("runSelectedCryptoAnalysis: Calculando indicadores para la cripto seleccionada...");
            currentSmaShortCache = calculateSMA(closingPrices, SMA_SHORT_PERIOD);
            currentSmaLongCache = calculateSMA(closingPrices, SMA_LONG_PERIOD);
            currentBollingerBandsCache = calculateBollingerBands(closingPrices, BB_PERIOD, BB_STD_DEV);
            currentRsiCache = calculateRSI(closingPrices, RSI_PERIOD); 
            
            console.log("runSelectedCryptoAnalysis: Renderizando gr치ficos para la cripto seleccionada...");
            renderPriceChart(currentPriceDataCache, currentSmaShortCache, currentSmaLongCache, currentBollingerBandsCache, currentRsiCache);
            
            console.log("runSelectedCryptoAnalysis: Actualizando se침ales individuales...");
            const signals = getCombinedSignals(currentSmaShortCache, currentSmaLongCache, currentRsiCache, currentBollingerBandsCache, closingPrices);
            updateSignals(currentSmaShortCache, currentSmaLongCache, currentRsiCache, currentBollingerBandsCache, closingPrices); // Actualiza los paneles individuales

            console.log("runSelectedCryptoAnalysis: Intentando guardar recomendaci칩n en backend...");
            // Pasamos currentPrice como el 칰ltimo par치metro
            await saveRecommendationToBackend(selectedSymbol, signals.overall, signals, currentPrice); 
            console.log("runSelectedCryptoAnalysis: Recomendaci칩n enviada a backend.");

            startUpdateTimer(UPDATE_INTERVAL_SELECTED_CRYPTO / 1000);
            console.log("An치lisis de criptomoneda seleccionada completado.");
        }

        async function updateAllCryptosOpportunities() {
            console.log("Inicio de updateAllCryptosOpportunities.");
            if (isProcessingAllCryptos) {
                console.log("Ya se est치 procesando el an치lisis de todas las criptos. Saltando esta ejecuci칩n.");
                return;
            }
            if (allCryptos.length === 0) {
                 console.warn("No hay criptomonedas en la lista est치tica para actualizar las oportunidades.");
                 renderOpportunityColumns({ buy: [], sell: [], hold: [], error: ['No hay criptos para mostrar.'] });
                 return;
            }

            isProcessingAllCryptos = true;
            console.log("updateAllCryptosOpportunities: Iniciando an치lisis para TODAS las criptomonedas (carga progresiva)...");

            const tempRecommendations = { buy: [], sell: [], hold: [], error: [] }; 
            renderOpportunityColumns(tempRecommendations);

            for (let i = 0; i < allCryptos.length; i++) {
                const symbol = allCryptos[i];
                console.log(`updateAllCryptosOpportunities: Procesando ${symbol} (${i + 1}/${allCryptos.length}).`);

                try {
                    const prices = await getCryptoData(symbol, BYBIT_INTERVAL, BYBIT_CATEGORY, BYBIT_LIMIT);

                    const minRequiredData = Math.max(SMA_LONG_PERIOD, BB_PERIOD, RSI_PERIOD);
                    if (!prices || prices.length < minRequiredData) {
                        console.warn(`[Todas las Cryptos] Datos insuficientes para ${symbol}.`);
                        tempRecommendations.hold.push(`${symbol} (Datos Insuficientes)`); 
                    } else {
                        const closingPrices = prices.map(p => p.y);
                        const smaShort = calculateSMA(closingPrices, SMA_SHORT_PERIOD);
                        const smaLong = calculateSMA(closingPrices, SMA_LONG_PERIOD);
                        const bollingerBands = calculateBollingerBands(closingPrices, BB_PERIOD, BB_STD_DEV);
                        const rsi = calculateRSI(closingPrices, RSI_PERIOD);

                        const signals = getCombinedSignals(smaShort, smaLong, rsi, bollingerBands, closingPrices);
                        
                        if (signals.overall === 'buy') {
                            tempRecommendations.buy.push(symbol);
                        } else if (signals.overall === 'sell') {
                            tempRecommendations.sell.push(symbol);
                        } else {
                            tempRecommendations.hold.push(symbol);
                        }
                    }

                } catch (error) {
                    console.error(`[Todas las Cryptos] Error al procesar ${symbol}:`, error);
                    tempRecommendations.hold.push(`${symbol} (Error)`); 
                }

                renderOpportunityColumns(tempRecommendations);

                if (i < allCryptos.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, ALL_CRYPTOS_API_DELAY));
                }
            }
            isProcessingAllCryptos = false;
            console.log("An치lisis de TODAS las criptomonedas completado.");
        }

        // Funci칩n auxiliar para obtener la recomendaci칩n combinada
        // MEJORA: L칩gica de confluencia m치s estricta
        function getCombinedSignals(smaShort, smaLong, rsi, bollingerBands, closingPrices) {
            let smaRec = 'hold';
            let rsiRec = 'hold';
            let bbRec = 'hold';

            const validSmaShort = smaShort ? smaShort.filter(v => v !== null) : [];
            const validSmaLong = smaLong ? smaLong.filter(v => v !== null) : [];
            if (validSmaShort.length >= 2 && validSmaLong.length >= 2) {
                const lastSmaShort = validSmaShort[validSmaShort.length - 1].y;
                const prevSmaShort = validSmaShort[validSmaShort.length - 2].y;
                const lastSmaLong = validSmaLong[validSmaLong.length - 1].y;
                const prevSmaLong = validSmaLong[validSmaLong.length - 2].y;
                if (prevSmaShort <= prevSmaLong && lastSmaShort > lastSmaLong) smaRec = 'buy';
                else if (prevSmaShort >= prevSmaLong && lastSmaLong < lastSmaLong) smaRec = 'sell';
            } else {
                // Si no hay suficientes datos v치lidos para SMA, la se침al SMA es "N/A"
                smaRec = 'N/A';
            }


            const validRsi = rsi ? rsi.filter(v => v !== null) : [];
            if (validRsi.length > 0) { // Necesita al menos un punto v치lido
                const lastRsi = validRsi[validRsi.length - 1].y;
                if (lastRsi > RSI_OVERBOUGHT) rsiRec = 'sell';
                else if (lastRsi < RSI_OVERSOLD) rsiRec = 'buy';
            } else {
                rsiRec = 'N/A';
            }

            const validBbUpper = (bollingerBands && bollingerBands.upper) ? bollingerBands.upper.filter(v => v !== null) : [];
            const validBbLower = (bollingerBands && bollingerBands.lower) ? bollingerBands.lower.filter(v => v !== null) : [];
            const lastPrice = closingPrices ? closingPrices[closingPrices.length - 1] : undefined; 

            if (validBbUpper.length > 0 && validBbLower.length > 0 && lastPrice !== undefined) {
                const lastBbUpper = validBbUpper[validBbUpper.length - 1].y;
                const lastBbLower = validBbLower[validBbLower.length - 1].y;
                if (lastPrice > lastBbUpper) bbRec = 'sell';
                else if (lastPrice < lastBbLower) bbRec = 'buy';
            } else {
                bbRec = 'N/A';
            }

            let buyCount = 0;
            let sellCount = 0;
            let naCount = 0; // Contar indicadores no disponibles

            if (smaRec === 'buy') buyCount++;
            else if (smaRec === 'sell') sellCount++;
            else naCount++; // Si es 'hold' o 'N/A'

            if (rsiRec === 'buy') buyCount++;
            else if (rsiRec === 'sell') sellCount++;
            else naCount++;

            if (bbRec === 'buy') buyCount++;
            else if (bbRec === 'sell') sellCount++;
            else naCount++;

            let overallRecommendation = 'hold';

            // L칩gica de Confluencia MEJORADA y m치s estricta
            // Solo si hay al menos 2 indicadores disponibles para decidir
            if ((buyCount + sellCount) >= 2) { 
                if (buyCount >= 2 && sellCount === 0) { // Al menos 2 compras y ninguna venta
                    overallRecommendation = 'buy';
                } else if (sellCount >= 2 && buyCount === 0) { // Al menos 2 ventas y ninguna compra
                    overallRecommendation = 'sell';
                } else { // Cualquier otro caso (empate, contradicci칩n, o solo 1 se침al fuerte)
                    overallRecommendation = 'hold';
                }
            } else { // Si no hay suficientes indicadores disponibles (por ejemplo, todos son N/A o solo 1 es v치lido)
                overallRecommendation = 'hold';
                console.log(`getCombinedSignals: Recomendaci칩n forzada a HOLD por datos insuficientes de indicadores individuales.`); // Depuraci칩n
            }
            
            console.log(`getCombinedSignals: Recs individuales: SMA=${smaRec}, RSI=${rsiRec}, BB=${bbRec}. Combinada: ${overallRecommendation}`); 
            return { sma: smaRec, rsi: rsiRec, bb: bbRec, overall: overallRecommendation };
        }

        // ===================================================================================
        // --- C칍DIGO DE INICIO Y EVENT LISTENERS ---
        // Este bloque DEBE estar al final del script para asegurar que todas las funciones
        // llamadas (`initStaticCryptoList`, `runSelectedCryptoAnalysis`, etc.) est칠n ya definidas.
        // ===================================================================================

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOM Cargado. Iniciando aplicaci칩n.");
            initStaticCryptoList(); 

            if (allCryptos.length > 0) {
                // Ejecuci칩n inicial y configuraci칩n de intervalos
                runSelectedCryptoAnalysis(); 
                updateAllCryptosOpportunities();
                loadHistoricalRecommendationsFromBackend(); 

                setInterval(runSelectedCryptoAnalysis, UPDATE_INTERVAL_SELECTED_CRYPTO);
                setInterval(updateAllCryptosOpportunities, UPDATE_INTERVAL_ALL_CRYPTOS); 
                setInterval(loadHistoricalRecommendationsFromBackend, HISTORY_UPDATE_INTERVAL); 
            } else {
                console.error("No se encontraron criptomonedas en la lista est치tica. La aplicaci칩n no puede iniciar correctamente.");
                priceNoDataMessage.textContent = "Error: No se encontraron criptomonedas en la lista.";
                priceNoDataMessage.style.display = 'flex';
                renderOpportunityColumns({ buy: [], sell: [], hold: [], error: ['No hay criptos en la lista.'] });
            }
        });

        coinSelect.addEventListener('change', runSelectedCryptoAnalysis);

        const indicatorCheckboxes = document.querySelectorAll('#indicator-selection-panel input[type="checkbox"]');
        indicatorCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                if (currentPriceDataCache) { 
                    renderPriceChart(currentPriceDataCache, currentSmaShortCache, currentSmaLongCache, currentBollingerBandsCache, currentRsiCache);
                } else {
                    console.warn("No hay datos en cach칠 para redibujar el gr치fico con los indicadores.");
                }
            });
        });

    </script>
</body>
</html>
